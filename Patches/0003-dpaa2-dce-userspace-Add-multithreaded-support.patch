From 731f9c4000c381b3550dbf0ee82d036479e63d63 Mon Sep 17 00:00:00 2001
From: Ahmed Mansour <ahmed.mansour@nxp.com>
Date: Thu, 11 Aug 2016 01:31:34 -0400
Subject: [PATCH 3/3] dpaa2/dce-userspace: Add multithreaded support

Keep track of multiple dce users and ensure dce resources remain
persistent until all users exit and not before. Add memory size checks
to protect kmalloc() from failing

Signed-off-by: Ahmed Mansour <ahmed.mansour@nxp.com>
---
 drivers/staging/fsl-dpaa2/dce/dce-userspace.c |   59 +++++++++++++++++++++----
 1 file changed, 50 insertions(+), 9 deletions(-)

diff --git a/drivers/staging/fsl-dpaa2/dce/dce-userspace.c b/drivers/staging/fsl-dpaa2/dce/dce-userspace.c
index 87da3b5..a856519 100644
--- a/drivers/staging/fsl-dpaa2/dce/dce-userspace.c
+++ b/drivers/staging/fsl-dpaa2/dce/dce-userspace.c
@@ -59,9 +59,6 @@ struct work_unit {
 	wait_queue_head_t reply_wait;
 };
 
-struct dce_session comp_session;
-struct dce_session decomp_session;
-
 static void dce_callback(struct dce_session *session,
 			uint8_t status,
 			dma_addr_t input,
@@ -78,6 +75,12 @@ static void dce_callback(struct dce_session *session,
 	wake_up(&work_unit->reply_wait);
 }
 
+static struct dce_session comp_session;
+static struct dce_session decomp_session;
+
+/* Track number of users of this driver and do not delete info prematurely */
+static atomic_t users;
+
 static int fsl_dce_dev_open(struct inode *inode, struct file *filep)
 {
 	struct dce_session_params params = {
@@ -95,14 +98,21 @@ static int fsl_dce_dev_open(struct inode *inode, struct file *filep)
 	};
 	int ret;
 
+	atomic_inc(&users);
+	if (atomic_read(&users) > 1)
+		return 0; /* No need to do anything, someone else did setup */
+
 	ret = dce_session_create(&comp_session, &params);
-	if (ret)
+	if (ret) {
+		atomic_dec(&users);
 		return -EACCES;
+	}
 
 	params.engine = DCE_DECOMPRESSION;
 	ret = dce_session_create(&decomp_session, &params);
 	if (ret) {
 		dce_session_destroy(&comp_session);
+		atomic_dec(&users);
 		return -EACCES;
 	}
 	return 0;
@@ -110,8 +120,17 @@ static int fsl_dce_dev_open(struct inode *inode, struct file *filep)
 
 static int fsl_dce_dev_release(struct inode *inode, struct file *filep)
 {
-	dce_session_destroy(&comp_session);
-	dce_session_destroy(&decomp_session);
+	int ret;
+
+	if (!atomic_dec_and_test(&users))
+		return 0;
+
+	ret = dce_session_destroy(&comp_session);
+	if (ret)
+		pr_err("Failed to close DCE compress session. ret = %d", ret);
+	ret = dce_session_destroy(&decomp_session);
+	if (ret)
+		pr_err("Failed to close DCE decompress session. ret = %d", ret);
 	return 0;
 }
 
@@ -134,7 +153,14 @@ static long fsl_dce_dev_ioctl(struct file *filep,
 		return -EIO;
 	}
 
-	input.vaddr = kmalloc(param.input_len, GFP_DMA);
+	/* return ENOMEM if attetmpt is made to allocate more than allowed */
+	if (param.input_len > KMALLOC_MAX_SIZE) {
+		pr_err("Input size requested, %zu, is too large\n",
+				param.input_len);
+		return -ENOMEM;
+	}
+
+	input.vaddr = kmalloc(param.input_len, GFP_KERNEL);
 	if (!input.vaddr)
 		goto err_alloc_in_data;
 	input.size = param.input_len;
@@ -146,9 +172,16 @@ static long fsl_dce_dev_ioctl(struct file *filep,
 		goto err_alloc_out_data;
 	}
 
-	output.vaddr = kzalloc(param.output_len, GFP_DMA);
+	if (param.output_len > KMALLOC_MAX_SIZE) {
+		ret = -ENOMEM;
+		pr_err("Output size requested, %zu, is too large\n",
+				param.output_len);
+		goto err_alloc_out_data;
+	}
+	output.vaddr = kzalloc(param.output_len, GFP_KERNEL);
 	if (!output.vaddr) {
 		ret = -ENOMEM;
+		pr_err("Unable to allocate mem in dce driver\n");
 		goto err_alloc_out_data;
 	}
 	output.size = param.output_len;
@@ -187,8 +220,15 @@ try_again:
 				DMA_BIDIRECTIONAL);
 	dma_unmap_single(&device->dev, output.paddr, output.size,
 				DMA_BIDIRECTIONAL);
-	if (work_unit.status != STREAM_END)
+	if (work_unit.status == OUTPUT_BLOCKED_DISCARD) {
+		pr_err("The output buffer supplied was too small\n");
+		ret = work_unit.status;
+		goto err_timedout;
+	} else if (work_unit.status != STREAM_END) {
 		pr_err("Unexpected DCE status 0x%x\n", work_unit.status);
+		ret = work_unit.status;
+		goto err_timedout;
+	}
 	ret = copy_to_user((void __user *)param.output, output.vaddr,
 			work_unit.output_produced);
 	if (ret) {
@@ -239,6 +279,7 @@ module_init(fsl_dce_dev_init);
 static void __exit fsl_dce_dev_exit(void)
 {
 	pr_info("%s\n", __func__);
+	misc_deregister(&fsl_dce_dev);
 }
 
 module_exit(fsl_dce_dev_exit);
-- 
1.7.9.5

